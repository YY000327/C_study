#define  _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//int main() {
//	int r = 7 / 2;
//	printf("%d\n", r);
//	double d = 7 / 2;
//	printf("%lf\n", d);
//	double b = 7 / 2.0;
//	printf("%lf\n",b);
//
//
//}
//% 操作符的两个操作数必须是整数

//移位操作符
//>>左移操作符
//<<右移操作符

//int main() {
//	int a = 15;
//	////00000000000000000000000000001111-原码
//	////00000000000000000000000000001111-反码
//	////00000000000000000000000000001111-补码
//	int b = a >> 1;
//
//	int c = -15;
//	//10000000000000000000000000001111-原码
//	//11111111111111111111111111110000-反码（原码的符号位不变，其他位取反是反码）
//	//11111111111111111111111111110001-补码（反码+1）
//
//	//整数在内存中存储的是补码
//	//计算的时候也是使用补码
//	return 0;
//}

//整数的二进制表示形式：原码、反码、补码
//正整数的原码、反码、补码都是相同的
//负整数的是不同的

//一个整型是4个字节=32bit位
//00000000000000000000000000001111
//符号位是第一位，1表示负数，0表示正数


//移位是移动的二进制的补码
//int main() {
//	int a = 15;
//	int b = a >> 1;
//	printf("%d\n", b);
//	printf("%d\n", a);
//
//
//}
//右移：
//算术右移（右边丢弃，左边补原来的符号位）
//逻辑右移（右边丢弃，左边直接补0）
//c语言没有规定那种右移，一边是算数右移

//int main() {
//	int a = - 15;
//	int b = a >> 1;
//	printf("%d\n", b);
//	printf("%d\n", a);
//	//11111111111111111111111111110001-补码
//	//右移1
//	//11111111111111111111111111111000-右移后补码
//	//11111111111111111111111111110111-反码
//	//10000000000000000000000000001000-原码，最终答案-8
//
//}

//int main() {
//	int a = 6;
//	//左移操作符-左边丢弃，右边补0
//	//00000000000000000000000000000110-6的补码
//
//	int b = a << 1;
//	a <<= 1;
//	printf("%d\n", b);
//
//	return 0;
//}

//位操作符

//int main() {
//	int a = 3;
//	// 0011
//	int b = -5;
//	// 1...0101-原码
//	// 1...1010-反码
//	// 1...1011-补码
//
//	int c = a & b;
//	//& -- 对应二进制位有0则为0.两个同时为1，才是1
//	// 0...0011
//	// 1...1011
//	// 0...0011-补码
//
//	printf("%d\n", c);
//
//	return 0;
//}

//int main() {
//	int a = 3;
//	// 0011
//	int b = -5;
//	// 1...0101-原码
//	// 1...1010-反码
//	// 1...1011-补码
//
//	int c = a | b;
//	//& -- 对应二进制位有1则为1.两个同时为0，才是0
//	// 0...0011
//	// 1...1011
//	// 1...1011-补码
//	// 1...0100-反码+1=原码
//	// 10..0101-原码 等于-5
//
//	printf("%d\n", c);
//
//	return 0;
//}


//int main() {
//	int a = 3;
//	// 0011
//	int b = -5;
//	// 1...0101-原码
//	// 1...1010-反码
//	// 1...1011-补码
//
//	int c = a ^ b;
//	//& -- 对应二进制位相同为0，相异为1
//	// 0...0011
//	// 1...1011
//	// 1...1000-补码
//	// 1...0111-反码
//	// 10..1000-原码 等于-8
//
//	printf("%d\n", c);
//
//	return 0;
//}

//int main() {
//	int a = 3;
//	int b = 5;
//	printf("%d %d\n", a, b);
//
//
//	//a = a + b;
//	//b = a - b;
//	//a = a - b;
//	//printf("%d %d\n", a, b);
//
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//
//	printf("%d %d\n", a, b);
//
//
//	return 0;
//}

//int main() {
//	int a = 3;
//	int b = 5;
//	//a^a --> 0
//	//a^0 = a
//	// 异或支持交换律
//	//a^b^a = 5
//	//011和101
//	//110和011
//	//101
//	//a^a^b = 5
//
//}

//求一个整数存在内存中的二进制中1的个数

//赋值操作符
//连续赋值，从右向左，但可读性不高
//


////单目操作符，只有一个操作数
//int main() {
//	int flag = 0;
//	if (flag == 0) {
//		printf("hh\n");
//	}if (!flag) {
//		printf("hh\n");
//	}
//	if (flag) {
//		printf("hh\n");
//	}
//}


////& *应用于指针
//int main() {
//	int a = 10;
//	int* pa = &a;//取出a的地址
//
//	*pa;//解引用操作符-通过pa中存放的地址找到指定的空间倘
//	int c = *pa;
//
//
//
//}


////sizeof不是函数，是操作符
//int main() {
//	printf("%d\n", sizeof(int));
//	int arr[10] = {0};
//	printf("%d\n", sizeof(arr));
//	return 0;
//}


//~ 按补码的二进制按位取反

//int main() {
//	//int a = 0;
//	//printf("%d\n", ~a);
//	//0...0000
//	//1...1111-补码
//	//1...1110
//	//1...0001
//	//int a = 13;
//	////01101
//	//a |= (1 << 4);
//	//printf("%d\n", ~a);
//
//	int a = 13;
//	//01101
//	a &= (~(1 << 4));
//	printf("%d\n", ~a);
//
//
//	return 0;
//
//}
//
//int main() {
//	int a = (int)3.14;//强制类型转换
//
//	return 0;
//}


//关系操作符，只能应用到适合的了类型上
//逻辑操作符
//&&--并且，||--或者
//&&操作符左边为假右边就不用计算了
//||操作符左边为真后面不用计算表了