#define  _CRT_SECURE_NO_WARNINGS 1

//数据结构：在内存种管理数据 ――――》速度快、带电存储
//数据库：在磁盘种管理数据	 ――――》速度慢、不带电存储
// 通讯录 -- 数组/顺序表
//链表
//树
//哈希表
//图
//算法就是对数据的处理方式

//数据结构 -- 严蔚敏 -c
//数据结构 -- 殷人昆 -cpp
//大话数据结构 -- 图画得很好


//时间复杂度和空间复杂度
// 
//时间复杂度是一个函数
// 
// 
// 
// F(N) = N^2 +2N + 10
//取影响最大的项
//大O渐进表示法：估算
//O(N^2),N^2会最大影响到整个函数，
//
//O(N)
//O(N^2) 的效率肯定比 O（N）的效率高

//O（1）并不是代表了1次，而是常数次

//大O符号：用于描述函数渐进行为的数学符号
//1. 常数1取代运行时间中的所有加法常数
//2.在修改后的运行次数函数中，只保留最高阶项
//3.如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶



//时间复杂度，最好 最坏 平均 -》时间复杂度是保守估计，取最坏 O(N)
//const char* strchr(const char* str, int character) {
//	while (*str) {
//		if (*str == character)
//			return str;
//		++str;
//	}
//}


//消失的数字
//从0到n的所有整数，但其中缺了一个，请编写代码找出那个消失的整数

//思路1：
//1.先冒泡排序--》时间复杂度 O（N^2)
//2.遍历，当前值+1没不等于下一个数字就是下一个数 -->O(N)
//O(N^2)

//思路2：
//1. x, 跟单身狗，异或
//O（N）

//思路3：
// 0-n等差数列计算和
//依次减去数据中的值，剩下的就是消失的数字

//思路3
//int missingNumber(int* nums, int numsSize) {
//    int N = numsSize;
//    int sum = ((0 + N) * (N + 1)) / 2;
//    for (int i = 0; i < numsSize; ++i) {
//        sum -= nums[i];
//    }
//    return sum;
//}

#include <stdio.h>

//思路2
int missingNumber(int* nums, int numsSize) {
    int x = 0;
    for (int i = 0; i < numsSize; ++i) {
        x ^= nums[i];
    }
    for (int i = 0; i <= numsSize; ++i) {
        x ^= i;
    }
    return x;
}
//下面这个循环等于一个1-10的数组
// 那么把num和[i]结合后就可以看成一个数组就缺一个数，并且里面有（1-n）*2个数
// x=0就会和任何数遍历，此时数组内部可能是[0,0,1,1,2,2,3,3,4,5,5,6,6,7,7,8,8,9,9]
// 这个时候异或 a^a^b^b^c^c^d^d^e^f^f = e; a^b^c^a^c^b = 0;
// 异或支持交换律
//


int main() {
    int arr[9] = { 0,1,2,3,5,6,7,8,9 };
    int ret = missingNumber(arr,9);
    printf("%d", ret);

    return 0;
}